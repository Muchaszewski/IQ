<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#
		EventGenerator[] damageTypes = new[]{
			new EventGenerator("Physical"),
			new EventGenerator("Fire"),
			new EventGenerator("Cold"),
			new EventGenerator("Lightning"),
			new EventGenerator("Poison"),
			new EventGenerator("Arcane"),
			new EventGenerator("Light"),
			new EventGenerator("Dark"),
		};

		EventGenerator[] regenState = new[]{
			new EventGenerator("Begin"),
			new EventGenerator("End"),
			new EventGenerator("Break"),
		};

		EventGenerator[] monsterEncounters = new[]{
			new EventGenerator("Common"),
			new EventGenerator("Uncommon"),
			new EventGenerator("Rare"),
			new EventGenerator("Unique"),
		};

		EventGenerator[] attackGenerator = new[]
		{
			new EventGenerator("Click"),
			new EventGenerator("MeeleAttack", null, EnumDirectiveEvent.CanAttack),
			new EventGenerator("RangeAttack", null, EnumDirectiveEvent.CanAttack),
			new EventGenerator("SpellCast", null, EnumDirectiveEvent.CanAttack),
			new EventGenerator("DealingDamage", damageTypes, EnumDirectiveEvent.Pack),
		};

		EventGenerator[] defendGenerator = new[]
		{
			new EventGenerator("Parry", null, EnumDirectiveEvent.CanFail),
			new EventGenerator("Block", null, EnumDirectiveEvent.CanFail),
			new EventGenerator("Evade", null, EnumDirectiveEvent.CanFail),
			new EventGenerator("TakingDamage", damageTypes, EnumDirectiveEvent.Pack),
		};

		EventGenerator[] regenGenerator = new[]
		{
			new EventGenerator("HealthRegen", regenState, EnumDirectiveEvent.Pack),
			new EventGenerator("ManaRegen", regenState, EnumDirectiveEvent.Pack),
			new EventGenerator("StaminaRegen", regenState, EnumDirectiveEvent.Pack),
		};

		EventGenerator[] itemGenerator = new[]
		{
			new EventGenerator("Get"),
			new EventGenerator("Drop"),
			new EventGenerator("Equip", null, EnumDirectiveEvent.CanFail),
			new EventGenerator("Buy", null, EnumDirectiveEvent.CanFail),
			new EventGenerator("Sell"),
		};

		EventGenerator[] miscGenerator = new[]
		{
			new EventGenerator("Save"),
			new EventGenerator("Load"),
			new EventGenerator("NewCharacter"),
		};

		EventGenerator[] fightGenerator = new[]
		{
			new EventGenerator("Win"),
			new EventGenerator("Lose"),
			new EventGenerator("ItemFound"),
			new EventGenerator("EnemiesFound", monsterEncounters, EnumDirectiveEvent.Pack),
			new EventGenerator("LookingForEnemies"),
			new EventGenerator("TravelPlanned"),
			new EventGenerator("TravelBroke"),
			new EventGenerator("TravelBegin"),
			new EventGenerator("TravelEnd"),
		};

		//First value cannot assign enum switch, use those to group next generators
        EventGenerator[] generator = new[]
        {
            new EventGenerator("Attack", attackGenerator),
			new EventGenerator("Defend", defendGenerator),
			new EventGenerator("Regen", regenGenerator),
			new EventGenerator("Item", itemGenerator, EnumDirectiveEvent.Empty, false),
			new EventGenerator("Misc", miscGenerator, EnumDirectiveEvent.Empty, false),
			new EventGenerator("Fight", fightGenerator, EnumDirectiveEvent.Empty, false),
        };

#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;

namespace InventoryQuest.InventoryQuest.Components.ActionEvents
{
	public class ActionEventManager 
	{
<#
		foreach (EventGenerator item in generator)
        { #>	
		//<#= item.Name #>
<#			if(item.IsSelfEvent)
			{#>
		public static EventHandler On<#= item.Name #> = delegate { };
		public static void On<#= item.Name #>_Invoke()
		{
			 On<#= item.Name #>.Invoke(null, EventArgs.Empty);
		}
<#			}#>
		public static class <#= item.Name #> 
		{
<#			while(true)
			{
				EventGenerator nextItem = item.NextItem();
				if(nextItem == null) { break; }
		#>

			public static EventHandler On<#= nextItem.Name #> = delegate { };
			public static void On<#= nextItem.Name #>_Invoke()
			{
				 On<#= nextItem.Name #>.Invoke(null, EventArgs.Empty);
			}
<#				if(nextItem.EnumDirective != EnumDirectiveEvent.Empty) {#>
			public static class <#= nextItem.Name #> 
			{
<#				}#>
<#				if(nextItem.EnumDirective == EnumDirectiveEvent.CanAttack) 
				{#>
				public static EventHandler OnCriticalStrike = delegate { };
				public static void OnCriticalStrike_Invoke()
				{
					 OnCriticalStrike.Invoke(null, EventArgs.Empty);
				}
<#				}#>
<#				if(nextItem.EnumDirective == EnumDirectiveEvent.CanAttack || nextItem.EnumDirective == EnumDirectiveEvent.CanFail) 
				{#>
				public static EventHandler OnSucces = delegate { };
				public static void OnSucces_Invoke()
				{
					 OnSucces.Invoke(null, EventArgs.Empty);
				}

				public static EventHandler OnFail = delegate { };
				public static void OnFail_Invoke()
				{
					 OnFail.Invoke(null, EventArgs.Empty);
				}
<#				}#>
<#				if(nextItem.EnumDirective == EnumDirectiveEvent.Pack)
				{
					foreach (EventGenerator packItem in nextItem.Events)
					{#>
					public static EventHandler On<#= packItem.Name #> = delegate { };
					public static void On<#= packItem.Name #>_Invoke()
					{
						 On<#= packItem.Name #>.Invoke(null, EventArgs.Empty);
					}
<#					}
				}#>
<#				if(nextItem.EnumDirective != EnumDirectiveEvent.Empty) {#>
			}
<#				}#>
<#			}#>
		}
<#		} #>
	}
}

<#+
        public class EventGenerator
        {
            public string Name;
            public EventGenerator[] Events;
            public EnumDirectiveEvent EnumDirective;
			public bool IsSelfEvent = true;
			public int nextIndex = -1;

            public EventGenerator(string name, EventGenerator[] events = null, EnumDirectiveEvent enumDirective = EnumDirectiveEvent.Empty, bool isSelfEvent = true )
            {
                Name = name;
                Events = events;
                EnumDirective = enumDirective;
				IsSelfEvent = isSelfEvent;
            }

			public EventGenerator NextItem()
			{
				nextIndex++;
				if(Events != null && nextIndex == Events.Count())
				{
					return null;
				}
				var nextItem = Events[nextIndex];
				if(nextItem.Events != null && nextItem.Events.Count() != 0 && nextItem.EnumDirective != EnumDirectiveEvent.Pack){
					EventGenerator nextNestedItem = null;
					nextNestedItem = nextItem.NextItem();
					if(nextNestedItem != null)
					{
						return nextNestedItem;
					}
				}
				return nextItem;
			}
        }

		public enum EnumDirectiveEvent
		{
			Empty,
			CanAttack,
			CanFail,
			Pack,
		}
#>